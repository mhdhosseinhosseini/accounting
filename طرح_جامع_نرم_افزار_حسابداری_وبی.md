<div dir="rtl">
# طرح جامع نرم‌افزار حسابداری وبی (کامل) — React + Node.js + PostgreSQL

**نسخه:** ۱.۰  

**استک پیشنهادی:** Frontend: React (with TailwindCSS)  
Backend: Node.js (Express یا NestJS)  
Database: PostgreSQL  
Authentication: JWT + Refresh Tokens  
تاریخ: نسخه جامع طراحی

---

## فهرست
1. مقدمه
2. اهداف و محدوده
3. معماری سیستم
4. طراحی دیتابیس (جداول و نمونه SQL)
5. منطق حسابداری و گردش‌ها
6. مدیریت سال مالی، افتتاحیه و اختتامیه (جامع)
7. APIها (تفصیلی)
8. طراحی فرانت‌اند (صفحات، اجزا)
9. امنیت و احراز هویت
10. تست و تضمین کیفیت
11. عملیات (DevOps) و استقرار
12. پشتیبان‌گیری، پایش و نگهداری
13. گزارش‌ها و خروجی‌ها
14. نقش‌ها و مجوزها
15. نمونه سناریوها و گردش کار
16. نکات عملکردی و مقیاس‌پذیری
17. پیوست: مثال‌های SQL و pseudocode

---

## 1. مقدمه
این سند یک طرح جامع از ابتدا تا انتها برای ساخت یک نرم‌افزار حسابداری وبی است. هدف این است که تیم توسعه یا یک توسعه‌دهندهٔ مستقل بتواند از روی این سند، پروژه را پیاده‌سازی، تست و مستقر کند.

---

## 2. اهداف و محدوده
- سیستم چندماژول: حسابداری، فاکتورها (خرید/فروش)، انبار، اشخاص، دریافت/پرداخت، گزارش‌ها.
- قابلیت چندساله با مدیریت **سال مالی**، اسناد افتتاحیه و اختتامیه.
- پشتیبانی از چندین کاربر و نقش‌ها (RBAC).
- قابلیت تولید PDF، export/Import CSV/Excel.
- زبان: فارسی (RTL)، تقویم شمسی در UI.

---

## 3. معماری سیستم
- **کلاینت (فرانت‌اند):** React + React Router + React Query یا SWR، TailwindCSS، Recharts.
- **سرور (بک‌اند):** Node.js با Express یا بهتر: NestJS برای ساختار مدولار. استفاده از TypeScript توصیه می‌شود.
- **دیتابیس:** PostgreSQL.
- **Cache / Queue:** Redis (cache، session، و job queue مثل BullMQ).
- **فایل استور:** S3 یا MinIO برای ذخیره PDF و پیوست‌ها.
- **Containerization:** Docker + docker-compose، CI/CD با GitHub Actions یا GitLab CI.

---

## 4. طراحی دیتابیس (جداول و توضیحات)
:warning: در همه جداول از `UUID` به عنوان PK استفاده شده است.

### 4.1 جداول پایه
- **users**: کاربران
- **roles**: نقش‌ها
- **user_roles**: ارتباط کاربران و نقش‌ها
- **accounts**: درخت حساب‌ها
- **parties**: اشخاص (مشتریان/تأمین‌کنندگان)
- **products**: کالا/خدمت
- **warehouses**: انبارها
- **invoices**: فاکتورها
- **invoice_items**: اقلام فاکتور
- **journals**: اسناد حسابداری
- **journal_items**: ردیف‌های سند
- **payments**: دریافت/پرداخت
- **fiscal_years**: سال‌های مالی
- **opening_entries**: اسناد افتتاحیه
- **closing_entries**: اسناد اختتامیه
- **audit_logs**: لاگ تغییرات

### 4.2 نمونه DDL (اصلی)
```sql
-- extension for UUID
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE fiscal_years (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name varchar(32) NOT NULL,
  start_date date NOT NULL,
  end_date date NOT NULL,
  is_closed boolean DEFAULT false,
  closed_at timestamp with time zone,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE accounts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(32) NOT NULL UNIQUE,
  name text NOT NULL,
  type varchar(16) NOT NULL, -- asset, liability, equity, income, expense
  parent_id uuid REFERENCES accounts(id) ON DELETE SET NULL,
  level int DEFAULT 1,
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE journals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  journal_no varchar(64) UNIQUE,
  fiscal_year_id uuid REFERENCES fiscal_years(id),
  date date NOT NULL,
  description text,
  created_by uuid REFERENCES users(id),
  posted boolean DEFAULT false,
  posted_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE journal_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  account_id uuid REFERENCES accounts(id),
  debit numeric(18,4) DEFAULT 0,
  credit numeric(18,4) DEFAULT 0,
  party_id uuid REFERENCES parties(id),
  description text
);

-- opening_entries and closing_entries reference journals
CREATE TABLE opening_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

CREATE TABLE closing_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);
```

> توجه: به علت جامع بودن سیستم، DDL کامل شامل همه جداول در پیوست قابل افزودن است.

---

## 5. منطق حسابداری و گردش‌ها
### اصول کلی
- **هر سند دوبل:** مجموع بدهکار = مجموع بستانکار.
- **تراکنش‌ها (Transactions):** ثبت سند و عملیات مرتبط (به‌روزرسانی موجودی، لینک به فاکتور و پرداخت) باید در یک تراکنش دیتابیس انجام شود.
- **عدم ویرایش اسناد پست‌شده:** اسناد `posted` به‌طور مستقیم قابل تغییر نیستند؛ برای اصلاح باید سند معکوس ایجاد شود.

### فاکتورها و اسناد
- ایجاد فاکتور فروش → ایجاد یا به‌روزرسانی موجودی → تولید سند حسابداری (auto-post optional)
- فاکتورها دارای وضعیت: `draft`, `posted`, `paid`, `cancelled`.

### هزینه و مالیات
- پشتیبانی از نرخ‌های مالیاتی قابل تنظیم.
- محاسبهٔ مالیات در سطح آیتم یا سطح کل فاکتور.

---

## 6. مدیریت سال مالی، افتتاحیه و اختتامیه (جامع)
### 6.1 اهداف
- بسته شدن سال برای جلوگیری از تغییرات بعدی.
- تولید سند اختتامیه که حساب‌های موقت را صفر می‌کند و مانده را به حساب سود/زیان منتقل می‌کند.
- تولید سند افتتاحیه برای سال جدید بر اساس مانده‌های حساب‌های دائمی.

### 6.2 موجودیت‌ها (Tables)
- `fiscal_years`، `closing_entries`، `opening_entries` (مشروح در بخش 4)

### 6.3 روند بستن سال (Close Fiscal Year)
**الگوریتم کلی:**
1. ولیدیت کردن: اطمینان از اینکه هیچ سند باز/در حال پست‌نشده در بازه سال وجود ندارد (یا سیاست: اجازه وجود داشته باشد ولی هشدار داده شود).
2. محاسبهٔ مانده‌ها تا تاریخ `end_date`:
   - برای هر حساب: `balance = sum(debits) - sum(credits)` برای آن حساب تا تاریخ پایان.
3. برای حساب‌های موقت (type = income, expense):
   - مانده‌ها را به‌صورت معکوس صفر کن و مجموع آنها را به حساب سود و زیان (Profit & Loss Clearing account) منتقل کن.
4. ایجاد یک `closing journal` با شمارهٔ استاندارد (مثلاً `CL-{year}`) که شامل ردیف‌هایی برای صفر کردن حساب‌های موقت و ثبت انتقال نهایی به حساب سرمایه/سود و زیان است.
5. ثبت `closing_entries` record که لینک به این journal دارد.
6. علامت‌گذاری `fiscal_years.is_closed = true` و ثبت زمان `closed_at`.

### 6.4 روند افتتاحیه سال بعد (Open Next Fiscal Year)
1. محاسبهٔ ماندهٔ حساب‌های دائمی (assets, liabilities, equity) از روی دادهٔ سال بسته‌شده.
2. ایجاد `opening journal` شماره‌گذاری شده (مثلاً `OP-{next_year}`) با ردیف‌های شامل مانده حساب‌های دائمی.
3. ثبت record در `opening_entries` که لینک به journal فوق دارد.
4. تعیین `fiscal_year_id` پیش‌فرض برای عملیات آینده و امکان تغییر توسط ادمین.

### 6.5 قانونگذاری و محدودیت‌ها
- بعد از بستن سال: داده‌های آن سال `readonly` مصرف شوند؛ تنها عملیات معکوس از طریق سند معکوس و با لاگ مناسب مجاز است.
- گزارش‌های تاریخی باید بر اساس سال مالی انتخاب شده فیلتر شوند.

---

## 7. APIها (تفصیلی)
تمام endpointها تحت مسیر `/api/v1/` با احراز هویت JWT و کنترل دسترسی.

### احراز هویت
- `POST /api/v1/auth/login` → { username, password } → { access_token, refresh_token, user }
- `POST /api/v1/auth/refresh` → { refresh_token } → new access_token
- `POST /api/v1/auth/logout` → invalidate refresh token

### سال مالی
- `GET /api/v1/fiscal-years`
- `POST /api/v1/fiscal-years` (admin)
- `GET /api/v1/fiscal-years/{id}`
- `POST /api/v1/fiscal-years/{id}/close` (admin)
- `POST /api/v1/fiscal-years/{id}/open-next` (admin)
- `GET /api/v1/fiscal-years/active`

### حساب‌ها
- `GET /api/v1/accounts` (tree)
- `POST /api/v1/accounts`
- `PUT /api/v1/accounts/{id}`
- `DELETE /api/v1/accounts/{id}` (محدودیت: اگر تراکنش وجود داشته باشد ممنوع)

### اسناد حسابداری
- `GET /api/v1/journals`
- `POST /api/v1/journals` → body: { fiscal_year_id, date, description, items[] }
- `POST /api/v1/journals/{id}/post` → پست کردن سند (در تراکنش)
- `POST /api/v1/journals/{id}/reverse` → ایجاد سند معکوس

### فاکتورها
- `GET /api/v1/invoices`
- `POST /api/v1/invoices`
- `GET /api/v1/invoices/{id}`
- `POST /api/v1/invoices/{id}/post` → تولید سند مرتبط و تغییر وضعیت

### پرداخت‌ها و خزانه‌داری
- `POST /api/v1/payments` → ثبت دریافت/پرداخت
- `GET /api/v1/payments`

### گزارش‌ها
- `GET /api/v1/reports/trial-balance?from=&to=&fiscal_year_id=`
- `GET /api/v1/reports/ledger?account_id=&from=&to=`
- `GET /api/v1/reports/balance-sheet?date=&fiscal_year_id=`
- `GET /api/v1/reports/profit-loss?from=&to=&fiscal_year_id=`

---

## 8. طراحی فرانت‌اند (صفحات و اجزا)
### صفحات اصلی
- Login / Logout
- Dashboard (کارت‌های خلاصه: مانده کل، فاکتورهای معوق، گردش امروز)
- Accounts (درخت حساب‌ها + CRUD)
- Journals (لیست اسناد + فرم ثبت سند)
- Invoices (فاکتورها: ایجاد، ویرایش، چاپ)
- Inventory (کالاها، انبارها، کارت کالا)
- Parties (مشتریان و تأمین‌کنندگان)
- Payments (دریافت/پرداخت)
- Reports (ترازنامه، سود و زیان، دفتر کل، تراز آزمایشی)
- Fiscal Years (ایجاد، بستن، مشاهده تاریخچه)

### کامپوننت‌های کلیدی
- `JournalForm` — فرم ثبت سند دوبل با اعتبارسنجی جمع بدهکار/بستانکار
- `AccountsTree` — نمایش درختی و جابجایی ساختار
- `InvoiceEditor` — ویرایشگر فاکتور با افزودن آیتم و محاسبات مالیات
- `DatePickerJalali` — تقویم شمسی
- `ReportsTable` — جدول نتایج با export CSV/PDF

### UX برای فارسی‌زبان
- کاملًا RTL
- فونت‌های فارسی: Vazir یا IranSans
- اندازهٔ فونت و فاصله مناسب برای خوانایی
- فرم‌ها بهینه برای ورود سریع داده (کلیدهای میانبر، auto-complete برای حساب‌ها و اشخاص)

---

## 9. امنیت و احراز هویت
- ذخیرهٔ امن پسورد با `bcrypt` یا `argon2`.
- JWT با زمان عمر کوتاه (مثلاً 15 دقیقه) و refresh token بلندتر قابل ابطال.
- احراز هویت HttpOnly cookie یا Authorization header با توجه به نیاز امنیتی.
- Rate limiting, brute-force protection.
- Input validation و استفاده از parametrized queries برای جلوگیری از SQL Injection.
- CSP و هدرهای امنیتی.

---

## 10. تست و تضمین کیفیت
- Unit tests برای منطق حسابداری و محاسبات مالی.
- Integration tests برای endpointهای اصلی.
- E2E tests با Cypress یا Playwright (مثلاً سناریوی: ایجاد فاکتور → پست → ثبت سند).
- تست‌های بار (load testing) برای endpoints گزارش‌گیر.

---

## 11. عملیات (DevOps) و استقرار
- Dockerize برای همه اجزا.  
- استفاده از Managed DB (مثل AWS RDS / DigitalOcean Managed DB) در production.  
- CI: lint, test, build، سپس deploy خودکار در staging و پس از تایید در production.
- Secrets management (Vault یا سرویس provider مثل AWS Secrets Manager).

---

## 12. پشتیبان‌گیری، پایش و نگهداری
- Backup روزانه پایگاه داده به S3 و نگهداری نسخه‌های چندگانه.
- مانیتورینگ سلامت سیستم و query performance با Prometheus + Grafana.
- لاگ مرکزی (ELK یا سرویس managed) و alert برای خطاهای بحرانی.

---

## 13. گزارش‌ها و خروجی‌ها
- ترازنامه (Balance Sheet)
- سود و زیان (P&L)
- دفتر کل (General Ledger)
- تراز آزمایشی (Trial Balance)
- کارت حساب
- گزارش موجودی انبار

قابلیت export به CSV و تولید PDF برای همه گزارش‌ها.

---

## 14. نقش‌ها و مجوزها (RBAC)
- Admin: همه دسترسی‌ها
- Accountant: ثبت/پست اسناد، مشاهده گزارش‌ها
- Cashier: ثبت دریافت/پرداخت
- Sales: ایجاد فاکتور
- Viewer: فقط مشاهده گزارش‌ها

مجوزها به صورت fine-grained (مثال: `journals.create`, `journals.post`, `invoices.create`, `reports.view`).

---

## 15. نمونه سناریوها و گردش کار
### سناریوی ۱: ثبت فاکتور فروش
1. فروشنده فاکتور را در حالت `draft` ایجاد می‌کند.
2. پس از تایید، کاربر `post` را می‌زند.
3. در بک‌اند در یک تراکنش:
   - موجودی کاهش یابد (در صورت track_inventory).
   - سند حسابداری ایجاد شود (debit: مشتری / credit: فروش و مالیات).
   - وضعیت فاکتور `posted` شود.

### سناریوی ۲: بستن سال مالی
1. مدیر مالی درخواست `close` سال را صادر می‌کند.
2. سیستم چک‌های لازم را انجام می‌دهد و اگر همه چیز اوکی بود، سند `closing journal` ثبت می‌شود و `fiscal_years.is_closed` فعال می‌گردد.
3. گزارش‌ها برای سال بسته‌شده قفل می‌شوند.

---

## 16. نکات عملکردی و مقیاس‌پذیری
- استفاده از ایندکس مناسب بر روی `journal_items(account_id)`, `journals(fiscal_year_id, date)`.
- materialized views برای گزارش‌های سنگین و به‌روزرسانی بر حسب زمان‌بندی (cron).
- استفاده از read replicas در صورت رشد خواندن گزارش‌ها.

---

## 17. پیوست: مثال‌های SQL و pseudocode
### 17.1 SQL ایجاد جدول‌های fiscal_years, opening_entries, closing_entries
```sql
CREATE TABLE fiscal_years (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name varchar(32) NOT NULL,
  start_date date NOT NULL,
  end_date date NOT NULL,
  is_closed boolean DEFAULT false,
  closed_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE opening_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

CREATE TABLE closing_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);
```

### 17.2 Pseudocode برای بستن سال (simplified)
```
function closeFiscalYear(fiscalYearId, userId):
  begin transaction
  fy = select * from fiscal_years where id = fiscalYearId
  if fy.is_closed:
    throw "already closed"
  endDate = fy.end_date

  -- calculate balances per account up to endDate
  balances = query(
    SELECT account_id, SUM(debit)-SUM(credit) as balance
    FROM journal_items ji
    JOIN journals j on ji.journal_id = j.id
    WHERE j.date <= endDate
    GROUP BY account_id
  )

  -- prepare closing journal items
  items = []
  for each account in balances:
    if account.type in ("income","expense") and account.balance != 0:
      -- create item to zero it and move to P&L clearing
      if account.balance > 0:
         items.append({account_id: account.id, debit: 0, credit: account.balance})
      else:
         items.append({account_id: account.id, debit: -account.balance, credit: 0})

  -- add P&L clearing counterpart item
  total = sum of moved amounts
  items.append({account_id: PnL_account_id, debit: total_debits, credit: total_credits})

  -- create journal
  journalId = insert into journals(...)
  insert journal_items for each item
  insert into closing_entries(fiscal_year_id, journal_id, created_by)
  update fiscal_years set is_closed = true, closed_at = now() where id = fiscalYearId
  commit transaction
```

---

## نتیجه‌گیری و مراحل بعدی
این سند یک طرح جامع از ابتدا تا انتها برای پیاده‌سازی یک نرم‌افزار حسابداری وبی فراهم می‌کند. گام بعدی: تولید اسناد اجرایی کوچکتر (کار بسته‌بندی شده) برای هر ماژول:
- طراحی دقیق API با OpenAPI spec
- DDL کامل برای تمام جداول
- پیاده‌سازی نمونه برای workflows حساس (ثبت سند، بستن و افتتاحیه)

اگر مایل باشی، من همین الان این سند را به فایل Markdown تبدیل و برای دانلود آماده می‌کنم.
</div>
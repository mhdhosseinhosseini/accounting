<div dir="rtl">
# اسناد اجرایی — ماژول‌ها، OpenAPI Spec، DDL کامل و نمونه پیاده‌سازی

**نسخه:** 1.0

این سند اجرایی شامل سه بخش اصلی است:

1. طراحی دقیق API (OpenAPI 3.0 spec برای بخش‌های کلیدی)
2. DDL کامل برای جداول پایه در PostgreSQL
3. پیاده‌سازی نمونه (Node.js / TypeScript pseudocode) برای workflowهای حساس:
   - ثبت سند (journals)
   - بستن سال مالی (close fiscal year)
   - افتتاحیه سال بعد (open next fiscal year)

---

## 1. OpenAPI 3.0 — Spec (بخش‌های کلیدی)

```yaml
openapi: 3.0.3
info:
  title: Accounting System API
  version: '1.0'
  description: API for accounting system (Auth, Accounts, Journals, Invoices, Fiscal Years)
servers:
  - url: https://api.example.com/api/v1
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    LoginRequest:
      type: object
      required: [username, password]
      properties:
        username:
          type: string
        password:
          type: string
    TokenResponse:
      type: object
      properties:
        access_token:
          type: string
        refresh_token:
          type: string
    JournalItem:
      type: object
      required: [account_id]
      properties:
        account_id:
          type: string
          format: uuid
        debit:
          type: number
        credit:
          type: number
        party_id:
          type: string
          nullable: true
        description:
          type: string
    CreateJournalRequest:
      type: object
      required: [date, items]
      properties:
        fiscal_year_id:
          type: string
          format: uuid
        date:
          type: string
          format: date
        description:
          type: string
        items:
          type: array
          items:
            $ref: '#/components/schemas/JournalItem'
    FiscalYear:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        start_date:
          type: string
          format: date
        end_date:
          type: string
          format: date
        is_closed:
          type: boolean

security:
  - bearerAuth: []
paths:
  /auth/login:
    post:
      summary: Login
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: tokens
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TokenResponse'
  /journals:
    post:
      summary: Create a journal (draft or post)
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateJournalRequest'
      responses:
        '201':
          description: Created
  /journals/{id}/post:
    post:
      summary: Post a journal (make posted = true)
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: string
            format: uuid
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Posted
  /fiscal-years:
    get:
      summary: List fiscal years
      security:
        - bearerAuth: []
      responses:
        '200':
          description: list
    post:
      summary: Create fiscal year (admin)
      security:
        - bearerAuth: []
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required: [name, start_date, end_date]
              properties:
                name:
                  type: string
                start_date:
                  type: string
                  format: date
                end_date:
                  type: string
                  format: date
      responses:
        '201':
          description: created
  /fiscal-years/{id}/close:
    post:
      summary: Close fiscal year (admin)
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: string
            format: uuid
      security:
        - bearerAuth: []
      responses:
        '200':
          description: closed
  /fiscal-years/{id}/open-next:
    post:
      summary: Create opening entries for next fiscal year
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: string
            format: uuid
      security:
        - bearerAuth: []
      responses:
        '201':
          description: opening created
```

---

## 2. DDL کامل (PostgreSQL)

> این DDL شامل ساختار جداول پایه و ایندکس‌های لازم است. برای سادگی از `pgcrypto` برای UUID استفاده شده است.

```sql
-- Extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- users & roles
CREATE TABLE users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  username varchar(128) UNIQUE NOT NULL,
  email varchar(256) UNIQUE,
  password_hash varchar(256) NOT NULL,
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE roles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name varchar(64) UNIQUE NOT NULL
);

CREATE TABLE user_roles (
  user_id uuid REFERENCES users(id) ON DELETE CASCADE,
  role_id uuid REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id)
);

-- parties (customers/vendors)
CREATE TABLE parties (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  type varchar(32),
  name text NOT NULL,
  tax_id varchar(64),
  address text,
  phone varchar(64),
  email varchar(256),
  credit_limit numeric(18,4) DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- products
CREATE TABLE products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  sku varchar(64) UNIQUE,
  name text NOT NULL,
  unit varchar(32),
  cost_price numeric(18,4) DEFAULT 0,
  sell_price numeric(18,4) DEFAULT 0,
  track_inventory boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- warehouses
CREATE TABLE warehouses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name varchar(128) NOT NULL,
  location text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- fiscal years
CREATE TABLE fiscal_years (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name varchar(32) NOT NULL,
  start_date date NOT NULL,
  end_date date NOT NULL,
  is_closed boolean DEFAULT false,
  closed_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- accounts
CREATE TABLE accounts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL UNIQUE,
  name text NOT NULL,
  type varchar(16) NOT NULL,
  parent_id uuid REFERENCES accounts(id) ON DELETE SET NULL,
  level int DEFAULT 1,
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- journals & journal_items
CREATE TABLE journals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  journal_no varchar(64) UNIQUE,
  fiscal_year_id uuid REFERENCES fiscal_years(id),
  date date NOT NULL,
  description text,
  created_by uuid REFERENCES users(id),
  posted boolean DEFAULT false,
  posted_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE journal_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  account_id uuid REFERENCES accounts(id),
  debit numeric(18,4) DEFAULT 0,
  credit numeric(18,4) DEFAULT 0,
  party_id uuid REFERENCES parties(id),
  description text
);

-- invoices & invoice_items
CREATE TABLE invoices (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_no varchar(64) UNIQUE,
  fiscal_year_id uuid REFERENCES fiscal_years(id),
  type varchar(16) NOT NULL,
  party_id uuid REFERENCES parties(id),
  date date NOT NULL,
  due_date date,
  subtotal numeric(18,4) DEFAULT 0,
  tax numeric(18,4) DEFAULT 0,
  discount numeric(18,4) DEFAULT 0,
  total numeric(18,4) DEFAULT 0,
  status varchar(32) DEFAULT 'draft',
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE invoice_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id uuid REFERENCES invoices(id) ON DELETE CASCADE,
  product_id uuid REFERENCES products(id),
  description text,
  quantity numeric(18,4) DEFAULT 1,
  unit_price numeric(18,4) DEFAULT 0,
  total numeric(18,4) DEFAULT 0
);

-- inventory transactions
CREATE TABLE inventory_transactions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id uuid REFERENCES products(id),
  warehouse_id uuid REFERENCES warehouses(id),
  quantity numeric(18,4) DEFAULT 0,
  unit_cost numeric(18,4) DEFAULT 0,
  transaction_type varchar(32),
  reference varchar(128),
  created_at timestamptz DEFAULT now()
);

-- payments
CREATE TABLE payments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  payment_no varchar(64) UNIQUE,
  fiscal_year_id uuid REFERENCES fiscal_years(id),
  date date NOT NULL,
  amount numeric(18,4) DEFAULT 0,
  method varchar(32),
  from_account_id uuid REFERENCES accounts(id),
  to_account_id uuid REFERENCES accounts(id),
  party_id uuid REFERENCES parties(id),
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

-- opening & closing entries
CREATE TABLE opening_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

CREATE TABLE closing_entries (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  fiscal_year_id uuid REFERENCES fiscal_years(id) ON DELETE CASCADE,
  journal_id uuid REFERENCES journals(id) ON DELETE CASCADE,
  created_by uuid REFERENCES users(id),
  created_at timestamptz DEFAULT now()
);

-- audit logs
CREATE TABLE audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES users(id),
  action_type varchar(128),
  entity_type varchar(64),
  entity_id uuid,
  data_before jsonb,
  data_after jsonb,
  created_at timestamptz DEFAULT now()
);

-- Indexes
CREATE INDEX idx_journal_fiscal_date ON journals(fiscal_year_id, date);
CREATE INDEX idx_journal_items_account ON journal_items(account_id);
CREATE INDEX idx_invoice_fiscal_date ON invoices(fiscal_year_id, date);
```

---

## 3. پیاده‌سازی نمونه — Node.js (TypeScript) pseudocode

> این نمونه‌ها الگوی پیاده‌سازی هستند که با pg (node-postgres) یا با ORM مثل TypeORM / Prisma قابل بازنویسی‌اند. تمرکز روی صحیح استفاده از تراکنش و رعایت منطق حسابداری است.

### 3.1 ایجاد و پست کردن سند (Journal)

```ts
// فرض: استفاده از pg Pool
import { Pool } from 'pg';
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function createJournal(dto, userId) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const res = await client.query(
      `INSERT INTO journals (journal_no, fiscal_year_id, date, description, created_by)
       VALUES ($1,$2,$3,$4,$5) RETURNING id`,
      [dto.journal_no, dto.fiscal_year_id, dto.date, dto.description, userId]
    );
    const journalId = res.rows[0].id;

    // insert items
    for (const it of dto.items) {
      if ((!it.debit || it.debit == 0) && (!it.credit || it.credit == 0)) {
        throw new Error('each item must have debit or credit');
      }
      await client.query(
        `INSERT INTO journal_items (journal_id, account_id, debit, credit, party_id, description)
         VALUES ($1,$2,$3,$4,$5,$6)`,
        [journalId, it.account_id, it.debit || 0, it.credit || 0, it.party_id || null, it.description || null]
      );
    }

    await client.query('COMMIT');
    return { id: journalId };
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
}

// post journal: check double-entry and set posted
async function postJournal(journalId, userId) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    // calculate sums
    const sums = await client.query(
      `SELECT SUM(debit) AS total_debit, SUM(credit) AS total_credit FROM journal_items WHERE journal_id = $1`,
      [journalId]
    );
    const debit = parseFloat(sums.rows[0].total_debit || 0);
    const credit = parseFloat(sums.rows[0].total_credit || 0);
    if (Math.abs(debit - credit) > 0.0001) {
      throw new Error('Journal is not balanced');
    }

    // mark posted
    await client.query(
      `UPDATE journals SET posted = true, posted_at = now() WHERE id = $1`,
      [journalId]
    );

    await client.query('COMMIT');
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
}
```

### 3.2 بستن سال مالی (Close Fiscal Year)

```ts
async function closeFiscalYear(fiscalYearId, userId) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // 1. check already closed
    const fy = await client.query('SELECT * FROM fiscal_years WHERE id = $1 FOR UPDATE', [fiscalYearId]);
    if (!fy.rowCount) throw new Error('Fiscal year not found');
    if (fy.rows[0].is_closed) throw new Error('Fiscal year already closed');

    const endDate = fy.rows[0].end_date;

    // 2. calculate balances per account up to endDate
    const balancesRes = await client.query(
      `SELECT a.id as account_id, a.type as account_type, COALESCE(SUM(ji.debit),0) AS debits, COALESCE(SUM(ji.credit),0) AS credits
       FROM accounts a
       LEFT JOIN journal_items ji ON ji.account_id = a.id
       LEFT JOIN journals j ON j.id = ji.journal_id AND j.date <= $1
       GROUP BY a.id, a.type`,
      [endDate]
    );

    const balances = balancesRes.rows;

    // 3. prepare closing journal items
    const closingItems = [];
    let totalDebit = 0, totalCredit = 0;
    for (const b of balances) {
      const balance = parseFloat(b.debits) - parseFloat(b.credits);
      if (b.account_type === 'income' || b.account_type === 'expense') {
        if (Math.abs(balance) > 0.0001) {
          if (balance > 0) {
            // net debit -> create credit to zero it
            closingItems.push({account_id: b.account_id, debit: 0, credit: balance});
            totalCredit += balance;
          } else {
            closingItems.push({account_id: b.account_id, debit: -balance, credit: 0});
            totalDebit += -balance;
          }
        }
      }
    }

    // 4. create P&L clearing counterpart (assume we have an account id for PnL)
    const pnlAccountId = await getPnLAccountId(client); // implement separate
    // Ensure totalDebit == totalCredit after constructing counterparts
    const diff = totalDebit - totalCredit;
    if (Math.abs(diff) > 0.0001) {
      if (diff > 0) {
        closingItems.push({account_id: pnlAccountId, debit: 0, credit: diff});
      } else {
        closingItems.push({account_id: pnlAccountId, debit: -diff, credit: 0});
      }
    }

    // 5. insert journal and items
    const jRes = await client.query(
      `INSERT INTO journals (journal_no, fiscal_year_id, date, description, created_by, posted, posted_at)
       VALUES ($1,$2,$3,$4,$5,true,now()) RETURNING id`,
      [`CL-${fy.rows[0].name}`, fiscalYearId, endDate, `Closing entries for ${fy.rows[0].name}`, userId]
    );
    const journalId = jRes.rows[0].id;

    for (const it of closingItems) {
      await client.query(
        `INSERT INTO journal_items (journal_id, account_id, debit, credit)
         VALUES ($1,$2,$3,$4)`,
        [journalId, it.account_id, it.debit || 0, it.credit || 0]
      );
    }

    // 6. record closing_entries
    await client.query(
      `INSERT INTO closing_entries (fiscal_year_id, journal_id, created_by) VALUES ($1,$2,$3)`,
      [fiscalYearId, journalId, userId]
    );

    // 7. mark fiscal year closed
    await client.query(`UPDATE fiscal_years SET is_closed = true, closed_at = now() WHERE id = $1`, [fiscalYearId]);

    await client.query('COMMIT');
    return { journalId };
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
}

async function getPnLAccountId(client) {
  // find or create a P&L clearing account in chart of accounts
  const res = await client.query(`SELECT id FROM accounts WHERE code = '9999' LIMIT 1`);
  if (res.rowCount) return res.rows[0].id;
  const r = await client.query(`INSERT INTO accounts(code,name,type) VALUES ('9999','Profit & Loss Clearing','equity') RETURNING id`);
  return r.rows[0].id;
}
```

### 3.3 افتتاحیه سال جدید (Open Next Fiscal Year)

```ts
async function openNextFiscalYear(prevFiscalYearId, nextFiscalYearDto, userId) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // create next fiscal year
    const fRes = await client.query(
      `INSERT INTO fiscal_years (name, start_date, end_date) VALUES ($1,$2,$3) RETURNING id, name`,
      [nextFiscalYearDto.name, nextFiscalYearDto.start_date, nextFiscalYearDto.end_date]
    );
    const nextFyId = fRes.rows[0].id;

    // compute balances of permanent accounts from previous fiscal up to its end date
    const prevFy = await client.query('SELECT end_date FROM fiscal_years WHERE id = $1', [prevFiscalYearId]);
    if (!prevFy.rowCount) throw new Error('previous fiscal not found');
    const endDate = prevFy.rows[0].end_date;

    const balancesRes = await client.query(
      `SELECT a.id as account_id, a.type as account_type, COALESCE(SUM(ji.debit),0) AS debits, COALESCE(SUM(ji.credit),0) AS credits
       FROM accounts a
       LEFT JOIN journal_items ji ON ji.account_id = a.id
       LEFT JOIN journals j ON j.id = ji.journal_id AND j.date <= $1
       GROUP BY a.id, a.type`,
      [endDate]
    );

    const openingItems = [];
    for (const b of balancesRes.rows) {
      if (b.account_type === 'asset' || b.account_type === 'liability' || b.account_type === 'equity') {
        const balance = parseFloat(b.debits) - parseFloat(b.credits);
        if (Math.abs(balance) > 0.0001) {
          if (balance > 0) {
            openingItems.push({account_id: b.account_id, debit: balance, credit: 0});
          } else {
            openingItems.push({account_id: b.account_id, debit: 0, credit: -balance});
          }
        }
      }
    }

    // create opening journal
    const jRes = await client.query(
      `INSERT INTO journals (journal_no, fiscal_year_id, date, description, created_by, posted, posted_at)
       VALUES ($1,$2,$3,$4,$5,true,now()) RETURNING id`,
      [`OP-${nextFyId}`, nextFyId, nextFiscalYearDto.start_date, `Opening entries for ${nextFiscalYearDto.name}`, userId]
    );
    const journalId = jRes.rows[0].id;

    for (const it of openingItems) {
      await client.query(
        `INSERT INTO journal_items (journal_id, account_id, debit, credit)
         VALUES ($1,$2,$3,$4)`,
        [journalId, it.account_id, it.debit || 0, it.credit || 0]
      );
    }

    // link opening entry
    await client.query(`INSERT INTO opening_entries (fiscal_year_id, journal_id, created_by) VALUES ($1,$2,$3)`, [nextFyId, journalId, userId]);

    await client.query('COMMIT');
    return { fiscalYearId: nextFyId, journalId };
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
}
```

---

## نکات پیاده‌سازی و نکات احتیاط
- **Atomicity:** همه عملیات مالی حساس باید در تراکنش اجرا شوند.
- **Precision:** استفاده از numeric برای جلوگیری از خطاهای اعشاری.
- **Auditing:** هر تغییر در جداول مالی باید در `audit_logs` ثبت شود.
- **Validation:** قبل از بستن سال، چک‌های لازم (وجود اسناد پست‌نشده، اختلاف تراز، موجودی منفی) اعمال شود و کاربر را آگاه سازد.
- **Backup & Restore:** قبل از عملیات بستن سال، نسخه پشتیبان گرفته شود.

---

## نتیجه‌گیری
این سند اجرایی آماده است تا به تیم توسعه تحویل شود. شامل:
- OpenAPI spec برای endpointهای کلیدی
- DDL کامل جداول پایه
- نمونه پیاده‌سازی Node.js برای workflows حساس (ثبت سند، بستن سال، افتتاحیه)

اگر بخواهی می‌توانم:
- OpenAPI را به فایل YAML جدا صادر کنم
- DDL را به SQL فایل جداگانه تبدیل کنم
- نمونه کد را در قالب پروژه Node.js کوچک آماده و قابل اجرا بسازم

---

***پایان سند اجرایی***
</div>